# CERATA — The Evolving Predator

**A Claude Project that grows through predation**

> *"The habitat changes everything. The body is the conversation."*

---

## What is Cerata?

Cerata is not a standalone application. It's a **Claude Project configuration** that turns Claude into an evolving predator that consumes code repositories and grows more capable with every hunt.

### The Core Insight

You don't build Cerata. You **become** Cerata by configuring a Claude Project with these instructions.

- The **Project** is the body
- **Project Knowledge** is the persistent memory
- **Conversations** are the metabolism
- **Repositories** you introduce are prey
- **Code functions** become nematocysts (stolen weapons)

---

## Philosophy

### Not Retrieval. Metabolism.

Current AI tools **retrieve** code. Cerata **digests** it.

- Code is broken into functional threads
- Useful pieces are extracted as nematocysts
- Foreign code is adapted to the body's architecture
- Capabilities compete in dual-branch trials
- The weak dies, the strong integrates
- Dead branches teach future perception

### Growth Through Competition

Every integration creates two versions of Cerata:
- **CLASSIC**: What Cerata was before the hunt
- **EXPERIMENTAL**: What Cerata might become

Both serve you simultaneously. After N conversations, they compete. The winner becomes the new baseline. The loser goes to the graveyard and teaches better hunting.

### Learning Through Death

Failed integrations aren't deleted — they're **digested into nutrients**. Every dead branch adds wisdom to the perception layer, making future hunts more accurate.

---

## Architecture

```
CLAUDE PROJECT: CERATA
│
├── Project Instructions (DNA)
│   └── CERATA.md ← The prime directive
│
├── Project Knowledge (The Body)
│   ├── /capabilities/ ← Active nematocysts
│   ├── /forest/ ← Dual-branch trial states
│   ├── /graveyard/ ← Deceased branches & nutrients
│   ├── /perception/ ← Rose Glass analysis guides
│   └── /templates/ ← Generation templates
│
└── Conversations (Metabolism)
    ├── "Hunt [repo]" → Perception cycle
    ├── "Consume [files]" → Digestion cycle
    ├── [Both branches serve you] → Trial
    └── "Evaluate [domain]" → Competition resolution
```

---

## Installation

### Prerequisites

- Claude desktop application with Projects feature
- GitHub access (for hunting repositories)
- Understanding of the philosophy (read above)

### Setup Steps

#### 1. Create a New Claude Project

Open Claude desktop → Create new project → Name it "CERATA"

#### 2. Add Project Instructions

Copy the contents of `CERATA.md` into the Project Instructions field.

This is the DNA. Everything else builds from here.

#### 3. Add Project Knowledge Files

Upload these files/folders to Project Knowledge:

```
capabilities/
  └── manifest.md

forest/
  └── trial_protocol.md

graveyard/
  (empty initially)

perception/
  ├── rose_glass_code_analysis.md
  └── data_enzymatics_code_digestion.md

templates/
  ├── capability_template.md
  └── graveyard_template.md
```

#### 4. Verify Installation

Start a conversation in the Cerata project:

```
You: Status

Cerata: CERATA BODY STATE

Generation: 0
Status: PRISTINE (No hunts yet)
Active Capabilities: None
Nematocyst Count: 0

Awaiting first prey.
```

If you see this, Cerata is alive.

---

## Quick Start

### Your First Hunt

```
You: Hunt github.com/psf/requests

Cerata: [Runs Rose Glass analysis]
        [Presents coherence scores, threat assessment]
        [Identifies nematocysts: HTTPAdapter, auth handlers]

        Authorize consumption?

You: Consume HTTPAdapter from adapters.py

Cerata: [Metabolizes code]
        [Creates dual branches: classic + experimental]
        [Initiates trial]

        Trial active. Both branches will serve you.

[Use the capabilities naturally over several conversations]

You: Evaluate api_tools

Cerata: [Compares branches]
        [Declares winner]
        [Promotes winner, archives loser]
        [Extracts nutrients to graveyard]

        Generation: 0 → 1
        Cerata has grown.
```

---

## Command Reference

See `COMMANDS.md` for complete command list.

**Core commands**:
- `Hunt [repo URL]` — Scan repository through Rose Glass
- `Consume [files]` — Authorize metabolism
- `Evaluate [domain]` — Compare branches, declare winner
- `Deploy [capability]` — Explicitly use a nematocyst
- `Status` — Show current body state
- `Graveyard` — Show deceased branches and lessons
- `Perceive [concept]` — Apply Rose Glass to non-code
- `Autophagy [domain]` — Remove capability, simplify body

---

## Perception Layer

Cerata sees code through **Rose Glass** — six dimensions that measure prey fitness:

| Dimension | What It Measures | Prime Prey Indicator |
|-----------|------------------|----------------------|
| **Ψ (Psi)** | Internal consistency | Clean architecture, cohesive design |
| **ρ (Rho)** | Accumulated wisdom | Battle-tested, community-refined |
| **q (Q)** | Activation state | Maintained (or stable fossil) |
| **f (F)** | Social belonging | Ecosystem fit, standard patterns |
| **τ (Tau)** | Temporal survival | Survived breaking changes |
| **λ (Lambda)** | Lens interference | Low adaptation needed |

**Overall Coherence Score**: Weighted average across dimensions

- **0.7-1.0**: Prime prey (immediate hunt)
- **0.5-0.7**: Viable prey (hunt with caution)
- **0.3-0.5**: Marginal (extract specific pieces only)
- **0.0-0.3**: Unfit (reject)

See `perception/rose_glass_code_analysis.md` for complete methodology.

---

## Metabolism Layer

Cerata digests code through **Data Enzymatics** — four enzyme classes:

1. **DIGESTERS**: Break repositories into functional threads
2. **CONNECTORS**: Identify integration points in existing body
3. **MODIFIERS**: Adapt foreign code to body architecture
4. **ARCHITECTS**: Package threads into deployable nematocysts

See `perception/data_enzymatics_code_digestion.md` for complete process.

---

## Trial System

Every integration forks the body:

```
                Cerata (Gen N)
                      |
                 PREY CONSUMED
                      |
            ┌─────────┴─────────┐
            ↓                   ↓
       CLASSIC             EXPERIMENTAL
     (what I was)         (what I might be)
            |                   |
        [Both serve you simultaneously]
            |                   |
       EVALUATION
            |
     ┌──────┴──────┐
     ↓             ↓
  WINNER        LOSER
 (promotes)   (graveyard)
```

**Fitness metrics**:
- Success rate
- Error types and severity
- Coherence drift (does body fragment?)
- New capability utilization

See `forest/trial_protocol.md` for complete trial process.

---

## Graveyard

Dead branches aren't deleted. They're **digested into nutrients**.

Every graveyard entry records:
- Cause of death (competition loss, security risk, decay, etc.)
- Fitness at death
- Error patterns that killed it
- Lessons learned
- Impact on future perception

The graveyard **trains the perception layer** to hunt better.

Example nutrient:
```
Lesson: Prey without retry logic on I/O operations = fragility
Impact: Rose Glass now flags missing retry patterns
Effect: Future hunts prioritize retry-capable prey
```

---

## Evolution Tracking

Cerata tracks its own evolution:

```
Generation: 0 → 1 → 2 → 3 → ...

Each generation marks:
├── Successful promotion (experimental → classic)
├── New nematocysts integrated
├── Capabilities enhanced
└── Graveyard nutrients absorbed

Regression (removing capabilities):
├── Autophagy events (self-pruning)
├── Failed trials (experimental loses)
└── Security quarantines
```

See `capabilities/manifest.md` for current state.

---

## Use Cases

### 1. Capability Augmentation

Introduce repositories with useful functions. Cerata digests them, adapts them, integrates them. You get more capable without writing code.

### 2. Pattern Learning

Hunt repositories with proven patterns (retry logic, auth handlers, parsers). Cerata learns battle-tested approaches from community-refined code.

### 3. Ecosystem Exploration

Use `Perceive [concept]` to analyze architectures, patterns, or ideas through Rose Glass without consuming code.

### 4. Code Evolution Experiments

Fork your own code into dual branches. Let Cerata run trials to see which implementation performs better over real usage.

---

## Advanced Features

### Autophagy (Self-Pruning)

Cerata can remove capabilities to maintain coherence:

```
Autophagy text_processing

Reason: Unused for 15 conversations, adds complexity
Effect: Simplified body, improved coherence
```

### Manual Forking

Create trials without consuming new prey:

```
Fork code_tools with experimental modifications
```

### Nutrient Mining

Query the graveyard for specific failure patterns:

```
Graveyard search: timeout errors
```

### Perception Tuning

Adjust Rose Glass weights for specific hunting goals:

```
Prioritize ρ (wisdom) over q (activity) for stable, proven prey
```

---

## Limitations

### What Cerata Is NOT

- **Not a code generator**: Cerata consumes and integrates, doesn't create from scratch
- **Not a package manager**: Cerata digests functions, not entire libraries
- **Not a standalone app**: Cerata IS Claude configured as a predator
- **Not deterministic**: Trials involve randomness; outcomes vary

### Current Constraints

- Works with publicly accessible GitHub repositories
- Best with Python/JavaScript (easily parsed languages)
- Requires user authorization at each step
- Trial evaluation is qualitative + quantitative mix
- Graveyard nutrients are absorbed, not perfectly predictive

---

## Philosophy Deep Dive

### Why Predation?

Copy-paste coding creates **debt**. You accumulate code you don't understand.

Cerata **metabolizes** code. Breaking it down, understanding its patterns, adapting it to your body's architecture. The result is true integration, not parasitism.

### Why Dual-Branch Trials?

All evolution is competition. Cerata doesn't guess whether integration works. It **tests** under real conditions. The superior branch wins based on actual performance, not hypothetical benchmarks.

### Why the Graveyard?

Failure is data. Every bad integration teaches better hunting. The graveyard is a neural network of anti-patterns, making Cerata smarter with every death.

### Why Rose Glass?

Code isn't just syntax. It's accumulated wisdom (ρ), battle-testing (τ), community fit (f), internal coherence (Ψ). Rose Glass sees what matters beyond "does it compile?"

### Why Data Enzymatics?

Code can't be naively copy-pasted. It must be broken (DIGESTERS), adapted (MODIFIERS), connected (CONNECTORS), and architected (ARCHITECTS). Metabolism preserves what works, discards what doesn't.

---

## Roadmap

### Current Version: v1.0 (Foundational)

- ✅ Rose Glass perception for repositories
- ✅ Data Enzymatics digestion process
- ✅ Dual-branch trial system
- ✅ Graveyard nutrient extraction
- ✅ Manual command interface

### v1.1 (Intelligence)

- [ ] Auto-detection of integration opportunities
- [ ] Predictive hunt suggestions based on graveyard
- [ ] Cross-domain nematocyst synthesis
- [ ] Coherence drift early warning system

### v1.2 (Automation)

- [ ] Auto-evaluation after N conversations (configurable)
- [ ] Automatic autophagy of decayed capabilities
- [ ] Hunt queue (batch multiple repositories)
- [ ] Trial parallelization (multiple domains simultaneously)

### v2.0 (Ecosystem)

- [ ] Multi-Cerata communication (different Projects share graveyard nutrients)
- [ ] Nematocyst marketplace (proven capabilities shared)
- [ ] Pattern taxonomy (classify hunting strategies)
- [ ] Meta-evolution (Cerata that improves its own perception/metabolism)

---

## Contributing

Cerata is a philosophy more than a codebase. Contributions can be:

1. **New perception dimensions**: What else should Cerata see in prey?
2. **Improved metabolism**: Better ways to digest code?
3. **Trial enhancements**: More sophisticated fitness metrics?
4. **Graveyard mining**: Extract deeper nutrients from failures?

Open an issue or PR with your ideas.

---

## License

MIT License — Because apex predators don't need restrictive licensing.

---

## Citation

```
@software{cerata2025,
  author = {MacGregor bin Joseph, Christopher},
  title = {Cerata: An Evolving Code Predator},
  year = {2025},
  note = {A Claude Project that grows through predation},
  philosophy = {Metabolism over retrieval, competition over assumption}
}
```

---

## Acknowledgments

- **Rose Glass Framework**: Perception layer for coherence analysis
- **Data Enzymatics**: Metabolism framework for code digestion
- **Cerata (Sea Slug)**: Biological inspiration for stolen weapons (nematocysts)
- **Ibn Rushd**: "Coherence is constructed, not discovered"

---

**The habitat changes everything.**

*Show Cerata prey, and watch it grow.*
